[
  {
    "path": "posts/2021-03-29-lists/",
    "title": "list and unlist",
    "description": "In which I continue to be confused about ::unlist, but manage to join two lists, as required",
    "author": [
      {
        "name": "Charles T. Gray",
        "url": "https://softloud.github.io/onetimetrophybitch/about.html"
      }
    ],
    "date": "2021-03-29",
    "categories": [
      "codeflow"
    ],
    "contents": "\n\n\n# pkgs used\nlibrary(tidyverse)\n\n\n\n\n\nfirst_list <-\n  list(\n    a = letters[1:3],\n    b = \"mittens\",\n    c = c(TRUE, FALSE),\n    d = rnorm(4)\n  )\n\nsecond_list <- \n  list(\n    e = \"buttons\",\n    f = letters[1:5],\n    g = runif(2)\n  )\n  \n\n# if I have a list(list, list) how do I get list of the elmenets of hte list? \n# Elements of first list as elements,\n# and elements of second list as elements?\n\nunlist(first_list, second_list) %>% \n  dim()\n\n\nNULL\n\n# huh dim?\n\nunlist(first_list, second_list) %>% \n  class()\n\n\n[1] \"character\"\n\n# character?!\n\nunlist(first_list, second_list)\n\n\n                  a1                   a2                   a3 \n                 \"a\"                  \"b\"                  \"c\" \n                   b                   c1                   c2 \n           \"mittens\"               \"TRUE\"              \"FALSE\" \n                  d1                   d2                   d3 \n\"-0.658853976666822\"  \"-1.29571869155379\" \"-0.541580614619811\" \n                  d4 \n\"-0.150846740435645\" \n\n# oh it made everything flat, that's not what I want. I still want the elements \n# to remain lists, what about this recursive argument?\n\nunlist(first_list, second_list, recursive = FALSE) \n\n\n                  a1                   a2                   a3 \n                 \"a\"                  \"b\"                  \"c\" \n                   b                   c1                   c2 \n           \"mittens\"               \"TRUE\"              \"FALSE\" \n                  d1                   d2                   d3 \n\"-0.658853976666822\"  \"-1.29571869155379\" \"-0.541580614619811\" \n                  d4 \n\"-0.150846740435645\" \n\n# okay, maybe I'm overthinking this, what happens if I make a list of two lists\nlist(first_list, second_list)\n\n\n[[1]]\n[[1]]$a\n[1] \"a\" \"b\" \"c\"\n\n[[1]]$b\n[1] \"mittens\"\n\n[[1]]$c\n[1]  TRUE FALSE\n\n[[1]]$d\n[1] -0.6588540 -1.2957187 -0.5415806 -0.1508467\n\n\n[[2]]\n[[2]]$e\n[1] \"buttons\"\n\n[[2]]$f\n[1] \"a\" \"b\" \"c\" \"d\" \"e\"\n\n[[2]]$g\n[1] 0.08550033 0.32802539\n\n# ugh, no I think I ended up with a list of 2 lists\nlist(first_list, second_list) %>% \n  str()\n\n\nList of 2\n $ :List of 4\n  ..$ a: chr [1:3] \"a\" \"b\" \"c\"\n  ..$ b: chr \"mittens\"\n  ..$ c: logi [1:2] TRUE FALSE\n  ..$ d: num [1:4] -0.659 -1.296 -0.542 -0.151\n $ :List of 3\n  ..$ e: chr \"buttons\"\n  ..$ f: chr [1:5] \"a\" \"b\" \"c\" \"d\" ...\n  ..$ g: num [1:2] 0.0855 0.328\n\n# see I have a list of 4 and a list of 3, I want a list of 7, not a list of 2 \n# comprising 4 and 3 ugh\n\n# can I use map to extract the elements?\nmap(first_list, 1)\n\n\n$a\n[1] \"a\"\n\n$b\n[1] \"mittens\"\n\n$c\n[1] TRUE\n\n$d\n[1] -0.658854\n\n# how is this different from first list?\nfirst_list\n\n\n$a\n[1] \"a\" \"b\" \"c\"\n\n$b\n[1] \"mittens\"\n\n$c\n[1]  TRUE FALSE\n\n$d\n[1] -0.6588540 -1.2957187 -0.5415806 -0.1508467\n\n# oh that's not what I want\n# fuck me, I'm going to look this up on the tubes now.\n\n\n\nAnd switch to a post. This is proving to be more involved than I thought.\nThis post on stackoverflow suggests using ::append, despite the function saying it is for vectors. Worth a try.\n\n\nappend(first_list, second_list)\n\n\n$a\n[1] \"a\" \"b\" \"c\"\n\n$b\n[1] \"mittens\"\n\n$c\n[1]  TRUE FALSE\n\n$d\n[1] -0.6588540 -1.2957187 -0.5415806 -0.1508467\n\n$e\n[1] \"buttons\"\n\n$f\n[1] \"a\" \"b\" \"c\" \"d\" \"e\"\n\n$g\n[1] 0.08550033 0.32802539\n\n# compare with \nfirst_list\n\n\n$a\n[1] \"a\" \"b\" \"c\"\n\n$b\n[1] \"mittens\"\n\n$c\n[1]  TRUE FALSE\n\n$d\n[1] -0.6588540 -1.2957187 -0.5415806 -0.1508467\n\nsecond_list\n\n\n$e\n[1] \"buttons\"\n\n$f\n[1] \"a\" \"b\" \"c\" \"d\" \"e\"\n\n$g\n[1] 0.08550033 0.32802539\n\nHuh, well, there you go. So a base function to the rescue.\n\n\n\n",
    "preview": {},
    "last_modified": "2021-07-08T15:54:41+01:00",
    "input_file": {}
  },
  {
    "path": "posts/2019-10-24-incorrigible-tidyvert/",
    "title": "incorrigible tidy::vert",
    "description": "a song with %>% references",
    "author": [
      {
        "name": "Charles T. Gray",
        "url": "https://twitter.com/cantabile"
      }
    ],
    "date": "2019-10-24",
    "categories": [
      "music"
    ],
    "contents": "\n\nContents\nincorrigible tidy::vert %>%  exegesis()\nthe %>% operator in the R language\nWhat is an operator?\nWhat is a composite?\n\nWhy do I love to %>%?\nincorrigible tidy::vert %>%  lyrics()\niphone balanced on music stand quality recording\n\nincorrigible tidy::vert %>%  exegesis()\n\nThis post will be adapted for inclusion in a joint publication of mathematically-informed artworks engaging with Magritte’s pipe, an icon of surrealism. This forthcoming publication is from a working group of researchers who met at the 2019 Heidelberg Laureate Forum.\n\n\nThank you, Laura Ación, Hao Ye, and James Goldie for checking the maths, and for the reflections on %>%.\n\nIn his 1929 surrealist painting, The Treachery of Images, René Magritte declares Ceci n’est pas une pipe (This is not a pipe). In so doing, he highlights this is but an image, a representation, of a pipe, not truly a pipe itself.\n\nThe Treachery of Images, René Magritte, 1929. Image source: wikipedia.\nI recently wrote a song with lots of references to R and the tidyverse:: metapackage(Wickham 2017).\nI didn't mean to %>% your bubble\nI'm just an incorrigible tidy::vert\nIn this post, I’ll unpack the pipe operator, %>%, that features throughout the lyrics.\nthe %>% operator in the R language\n\n\n\nFigure 1: Image source: magritrr:: GitHub repository.\n\n\n\nThe %>% pipe operator is the first major concept introduced in the programming section, following exploratory data analysis and data wrangling, of Wickham’s R for Data Science (Grolemund and Wickham 2017).\nWith Stefan Milton Bache’s magrittr::(Bache and Wickham 2014) package,\n\n\n# f(x) is equivalent to x %>% f() with magrittr::\n\nlibrary(magrittr)\n\n# f(x)\nround(3.1)\n\n\n[1] 3\n\n# is equivalent to x %>% f()\n\n3.1 %>% round()\n\n\n[1] 3\n\nWhat is an operator?\nWe often forget that operators are, themselves, functions.\nBrian A. Davey’s MAT4GA General Algebra coursebook (what I have on hand) provides this definition.\nFor \\(n \\in \\mathbb N_0 := \\mathbb N \\cup \\{ 0\\}\\), a map \\(f : A^n \\to A\\) is called an n-ary operation on A.\nFor example, \\(+\\) is a function that takes two arguments, numbers, and returns a single number. Algebraically, 3 + 2 = 5 is shorthand for +(3, 2) = 5.\nFor those with formal mathematical training, multiple uses of the %>% operator in a single line of code can be thought of in terms of a coding instantiation of a composite of functions.\nWhat is a composite?\nLet \\(f\\) and \\(g\\) be real functions.\nThe composite of \\(f\\) with \\(g\\) is the real function \\(g \\circ f\\) given by the formula \\((g \\circ f)(x) := g(f(x))\\).\nFor reasons that only made sense to me once I reached graduate-level mathematics, we read a composite of functions from right to left.\nAnd just to break our brains a little, algebraically, the composite operator is a function, so we have \\(g \\circ f = \\circ (f, g)\\)!\nThe pipe, %>%, operator is the R-language equivalent to the composite \\(\\circ\\) operator on real functions.\nWhy do I love to %>%?\nHere is an example with three functions: \\((h \\circ g \\circ f)(x) := h(g(f(x))).\\)\n\n\nset.seed(39)\n\n# get a random sample size between 20 & 100\nsample(seq(20, 100), 1) %>% # this f(x) goes into\n  # generate sample from normal distribution with \n  # mean 50 & sd 0.5\nrnorm(., 50, 0.5) %>% # g, so, now g(f(x), which goes into\n  # calculate mean of that sample\n  mean() # h, so h(g(f(x)))\n\n\n[1] 49.94228\n\nTo see how this is the \\((h \\circ g \\circ f)(x)\\) instantiation, reading from right to left, we take a look at the \\(h(g(f(x)))\\) instantiation of the same code.\n\n\n# this line of code is equivalent to above\n# h(g(f(x))) is less text\n# but the algorithm is harder to ascertain \nmean(rnorm(sample(seq(20, 100), 1), 50, 0.5))\n\n\n[1] 49.98828\n\nThe reader is invited to consider if they agree with the author that it is harder to read the symbols so close together, in this \\(h(g(f(x)))\\) instantiation of the code. Also, arguably more importantly, one does not have the ability to comment each component of the algorithm.\nThere is a downside to the %>%, however. The longer a composite becomes, the more difficult it is to identify errors.\n \nOn the the train Leipzig with snow falling\nAnd my %>%s are getting too long\n\nincorrigible tidy::vert %>%  lyrics()\n\n\n\nCaught the train to Leipzig, snow is falling\nBut I am not nearly done\nRube Goldberging this algorithm\nBut the sampling is off.\n\nI didn't mean to %>% your bubble\nI'm just an incorrible tidy::vert\n\nAnd I'm here to tell ya\nThere's some rhyme and reason\nBut there's a whole lot that can get fucked up\n\nAnd I'm here to tell ya\nThere's scarce rhyme and reason\nSo let's brace for the shitstorm\n\nDon't think I'll unravel\nThe mysteries of the beta distribution\nOn the the train Leipzig with snow falling\nAnd my %>%s are getting too long\n\nBut I didn't mean to %>% your bubble\nI'm just an incorrible tidy::vert\n\nAnd I'm here to tell ya\nThere's some rhyme and reason\nBut there's a whole lot that can get fucked up\n\nAnd I'm here to tell ya\nThere's scarce rhyme and reason\nSo let's brace for the CRANstorm\n\nAnd I didn't mean to %>% your bubble\nLet your flame war flame itself out\nAnd I didn't mean to %>% your bubble\nExcuse Me, Do You Have a Moment \n to Talk About Version Control?\n\nAnd I didn't mean to %>% your bubble\nI'm just an incorrible tidy::vert\nAnd I didn't mean to %>% your bubble\nI'm just an incorrible tidy::vert\n\n\niphone balanced on music stand quality recording\nDon’t say I didn’t warn you about the sound quality.\n\n\n\n\n\nBache, Stefan Milton, and Hadley Wickham. 2014. “Magrittr: A Forward-Pipe Operator for R.”\n\n\nGrolemund, Garrett, and Hadley Wickham. 2017. R for Data Science.\n\n\nWickham, Hadley. 2017. “Tidyverse: Easily Install and Load the ’Tidyverse’.”\n\n\n\n\n",
    "preview": "posts/2019-10-24-incorrigible-tidyvert/pipe-logo.png",
    "last_modified": "2021-07-15T17:04:56+01:00",
    "input_file": {}
  },
  {
    "path": "posts/2019-03-28-quack-quack-said-the-duck/",
    "title": "quack! quack! said the duck",
    "description": "making sense of methods in R",
    "author": [
      {
        "name": "cantabile",
        "url": {}
      }
    ],
    "date": "2019-03-28",
    "categories": [
      "dev"
    ],
    "contents": "\n\nContents\nafter a cursory look at UseMethod documentation\nmake a duck quack, with a little help from Josiah\nstuff I still don’t get\nmeritget\na duck for maelle\n\n\nSome time back, @malco_barrett and I discovered we both had tidyverse::-integrated functions in development for meta-analysis models, specifically models produced by metafor::rma.\nWe started to discuss how to bring together the work we’d done, and then, speaking for myself, I got busy and overwhelmed last year with the general craziness that doing a doctorate is, and this slipped way back on the backburner.\nLast week, however, one of the creators of the broom:: package got in touch with Malcolm about porting the code. And, with the Evidence Synthesis Hackathon imminent, it seems as if the time is nigh. If I’m going to be able to collaborate on this, that means finally getting around to learning about methods in R.\n\n\nCracks metaphoric R knuckles.So, S3. What's that all about?\n\n— Charles T. Gray (@cantabile) March 27, 2019\n\nI think I might find this pedagogically interesting in future, to reflect on where I started today, and where I ended up.\n\n\nJourney begins here: my current impression is that, digging back 8 years ago to my one compsci subject, first year java, S3 is a method for an object.\n\n— Charles T. Gray (@cantabile) March 27, 2019\n\nafter a cursory look at UseMethod documentation\nRecently someone, I think it was @kiersi, was asking on twitter how people learn. Today I learnt that I like to play first, ask questions of the documentation after.\nMike Penguin said something about UseMethod on twitter, so I thought I’d start there.\n\n\nOnce I realized that myfun <- function(x, …) UseMethod(“myfun”) is the boilerplate needed I was away. It does magic so that the methods you write i.e. myfun.myclass work like myfun(x) where class(x) includes“my class”\n\n— Michael Sumner (@mdsumner) March 27, 2019\n\n\n\n# i guess i need an object for my function to act on\nfluffyduck <- \"i am a duck\"\n\n# i wonder if you can define your own class?\nclass(fluffyduck) <- \"duck\"\nclass(fluffyduck)\n\n\n[1] \"duck\"\n\n# the UseMethod documentation said the method needs to act on an object\nis.object(fluffyduck)\n\n\n[1] TRUE\n\n# make a function \nfirstquack <- function() {cat(\"quack\")}\n\n# see if it works\nfirstquack()\n\n\nquack\n\n\n\n# but this throws an error\nUseMethod(\"firstquack\", duck)\n\n\nError in eval(expr, envir, enclos): object 'duck' not found\n\n# okay, time to look to the tubes for help\n\n\n\nmake a duck quack, with a little help from Josiah\n\n\nThis! I wrote a post about it and used my PR to janitor as an example. https://t.co/Vn7H3BAQjm\n\n— Josiah Parry (@JosiahParry) March 28, 2019\n\nJosiah’s post was most helpful, indeed. These are my notes.\n\n\n# start by creating a \"generic\" function\nquack <- function(says_the_duck, greeting = \"quack!\") {\n  UseMethod(\"quack\")\n}\n\n\n\nThe generic function seems like an instantiation step. I read this as, I will create a function called this that I can control how it behaves for different classes.\n\n\nquack() # okay, same error as josiah's, so far so good\n\n\nError in UseMethod(\"quack\"): no applicable method for 'quack' applied to an object of class \"NULL\"\n\nSidenote, set chunk option error=TRUE to display code and output for an error.\nMakes sense that this throws an error, we haven’t told it how to behave for anything yet.\n\n\n# set up a default method\nquack.default <-\n  function(says_the_duck = \"quack!\",           greeting = \"quack! \") {\n    print(paste0(greeting, says_the_duck))\n    cat(\"said the duck\")\n  }\n\n# check this default works for anything\nquack(NULL) # yay! it quacked on NULL\n\n\n[1] \"quack! \"\nsaid the duck\n\nquack() # and no argument?\n\n\n[1] \"quack! quack!\"\nsaid the duck\n\nquack(\"i'm a duck\") # a string?\n\n\n[1] \"quack! i'm a duck\"\nsaid the duck\n\n# now to make a fluffyduck-class object\nfluffyduck <- \"i am fluffy\" # create an object\nclass(fluffyduck) <- \"fluffyduck\" # set class of object\n\n# trying this before referring back to the post\nquack.fluffyduck <- function(says_the_duck, greeting = \"quack! \") {\n  print(paste0(greeting, says_the_duck))\n  cat(\"said the fluffy duck\\n\")\n}\n\n# does the duck quack?\nquack(fluffyduck)\n\n\n[1] \"quack! i am fluffy\"\nsaid the fluffy duck\n\n# try another object\nanother_fluffy_duck <- \"i am the fluffiest!\"\n\n# test default\nquack(another_fluffy_duck)\n\n\n[1] \"quack! i am the fluffiest!\"\nsaid the duck\n\n# but this duck is also fluffy!\nclass(another_fluffy_duck) <- \"fluffyduck\"\nquack(another_fluffy_duck)\n\n\n[1] \"quack! i am the fluffiest!\"\nsaid the fluffy duck\n\n# now to test changing my default greeting, to understand how to parse other arguments\nquack(another_fluffy_duck, greeting = \"a most fluffy day to you, \")\n\n\n[1] \"a most fluffy day to you, i am the fluffiest!\"\nsaid the fluffy duck\n\nstuff I still don’t get\nI don’t understand what all the words mean in these definitions of S3 and S4.\n\n4 works similarly to S3, but is more formal. There are two major differences to S3. S4 has formal class definitions, which describe the representation and inheritance for each class, and has special helper functions for defining generics and methods. S4 also has multiple dispatch, which means that generic functions can pick methods based on the class of any number of arguments, not just one. - Advanced R\n\nDoes multiple dispatch mean that the method can be conditional on the class of more than one argument?\nThis was fun; despite me finishing with more questions than I began with.\nmeritget\nMuch obliged to @jacinta for suggesting I update; the internet’s highest honour, gif-phrased praise.\n\n\nFluffy duck! :) pic.twitter.com/9HUPVaXAL4\n\n— Dr Jenny Richmond (@JenRichmondPhD) March 28, 2019\n\na duck for maelle\n\n\n# a duck for maelle!\nmaelles_duck <- \"je suis une cane\"\nclass(maelles_duck) <- \"frenchduck\"\n\n# french ducks speak in french\nquack.frenchduck <- function(says_the_duck, greeting = \"coin! \") {\n  print(paste0(greeting, says_the_duck))\n  cat(\"dit la cane\\n\")\n}\n\n# coin?\nquack(maelles_duck)\n\n\n[1] \"coin! je suis une cane\"\ndit la cane\n\n\n\n\n",
    "preview": {},
    "last_modified": "2021-07-08T16:20:32+01:00",
    "input_file": {}
  }
]
